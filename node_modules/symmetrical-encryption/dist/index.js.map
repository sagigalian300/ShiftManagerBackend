{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import crypto from \"crypto\"\n\n/**\n * Valid encodings for the encrypted data. Default is \"base64\".\n */\nexport type ValidEncodings = \"hex\" | \"base64\" | \"latin1\"\n\n//test\n\nconst algorithm = \"aes-256-gcm\"\nconst tagLength = 16 // Authentication tag length in bytes\nconst defaultEncoding: ValidEncodings = \"base64\"\nconst ivLength = 16 // AES block size in bytes for GCM mode\nconst saltLength = 64 // Length of the salt in bytes\nconst keyLength = 32 // Length of the key in bytes (for aes-256-gcm)\nconst encodingSeparator = \":\" // Separator for encoding and encrypted data\n\n/**\n * This function encrypts the data using the secretKey and returns the encrypted data\n * @param data // The data to encrypt\n * @param secretKey // The secret key to encrypt the data\n * @param options // Optional parameter to specify the encoding of the encrypted data.\n * Valid values are \"hex\", \"base64\", and \"latin1\". Default is \"base64\"\n */\nexport const encrypt = (data: string, secretKey: string, options?: { encoding: ValidEncodings }): string => {\n    if (!data || typeof data !== \"string\" || !secretKey || typeof secretKey !== \"string\") {\n        throw new Error(\"[symmetrical-encryption] data and secretKey must be non-empty strings\")\n    }\n    const encoding = options?.encoding ?? defaultEncoding\n\n    const iv = crypto.randomBytes(ivLength)\n    const salt = crypto.randomBytes(saltLength) // Generate a random salt\n    const key = crypto.scryptSync(secretKey, salt, keyLength) // Derive a key from the secret and the salt\n    const cipher = crypto.createCipheriv(algorithm, key, iv)\n    const encryptedText = Buffer.concat([cipher.update(data, \"utf8\"), cipher.final()])\n    const authTag = cipher.getAuthTag()\n    // Prepend the salt, IV, and authTag to the encrypted data for use in decryption\n    const result = Buffer.concat([salt, iv, authTag, encryptedText]).toString(encoding)\n\n    return `${encoding}${encodingSeparator}${result}`\n}\n\n/**\n * This function decrypts the data using the secretKey and returns the decrypted data.\n * @param data // The encrypted data\n * @param secretKey // The secret key to decrypt the data.\n * Must be the same key as the one used for encryption.\n */\nexport const decrypt = (data: string, secretKey: string): string => {\n    if (!data || typeof data !== \"string\" || !secretKey || typeof secretKey !== \"string\") {\n        throw new Error(\"[symmetrical-encryption] data and secretKey must be non-empty strings\")\n    }\n\n    try {\n        const encodingIndex = data.indexOf(encodingSeparator)\n        const encoding = data.substring(0, encodingIndex) as ValidEncodings\n        const encryptedData = data.substring(encodingIndex + 1)\n\n        const rawData = Buffer.from(encryptedData, encoding)\n        const salt = rawData.subarray(0, saltLength)\n        const iv = rawData.subarray(saltLength, saltLength + ivLength)\n        const authTagIndex = saltLength + ivLength\n        const authTag = rawData.subarray(authTagIndex, authTagIndex + tagLength)\n        const encryptedText = rawData.subarray(authTagIndex + tagLength)\n        const key = crypto.scryptSync(secretKey, salt, keyLength)\n        const decipher = crypto.createDecipheriv(algorithm, key, iv)\n        decipher.setAuthTag(authTag)\n\n        return decipher.update(encryptedText) + decipher.final(\"utf8\")\n        // eslint-disable-next-line\n    } catch (error: any) {\n        if (error?.message === \"Unsupported state or unable to authenticate data\") {\n            throw new Error(`[symmetrical-encryption] Invalid secret key or corrupted data`)\n        } else {\n            throw new Error(`[symmetrical-encryption] Unexpected error: ${error?.message}`)\n        }\n    }\n}\n"],"mappings":"AAAA,OAAOA,MAAY,SASnB,IAAMC,EAAY,cACZC,EAAY,GACZC,EAAkC,SAClCC,EAAW,GACXC,EAAa,GACbC,EAAY,GACZC,EAAoB,IASbC,EAAU,CAACC,EAAcC,EAAmBC,IAAmD,CACxG,GAAI,CAACF,GAAQ,OAAOA,GAAS,UAAY,CAACC,GAAa,OAAOA,GAAc,SACxE,MAAM,IAAI,MAAM,uEAAuE,EAE3F,IAAME,EAAWD,GAAS,UAAYR,EAEhCU,EAAKb,EAAO,YAAYI,CAAQ,EAChCU,EAAOd,EAAO,YAAYK,CAAU,EACpCU,EAAMf,EAAO,WAAWU,EAAWI,EAAMR,CAAS,EAClDU,EAAShB,EAAO,eAAeC,EAAWc,EAAKF,CAAE,EACjDI,EAAgB,OAAO,OAAO,CAACD,EAAO,OAAOP,EAAM,MAAM,EAAGO,EAAO,MAAM,CAAC,CAAC,EAC3EE,EAAUF,EAAO,WAAW,EAE5BG,EAAS,OAAO,OAAO,CAACL,EAAMD,EAAIK,EAASD,CAAa,CAAC,EAAE,SAASL,CAAQ,EAElF,MAAO,GAAGA,IAAWL,IAAoBY,GAC7C,EAQaC,EAAU,CAACX,EAAcC,IAA8B,CAChE,GAAI,CAACD,GAAQ,OAAOA,GAAS,UAAY,CAACC,GAAa,OAAOA,GAAc,SACxE,MAAM,IAAI,MAAM,uEAAuE,EAG3F,GAAI,CACA,IAAMW,EAAgBZ,EAAK,QAAQF,CAAiB,EAC9CK,EAAWH,EAAK,UAAU,EAAGY,CAAa,EAC1CC,EAAgBb,EAAK,UAAUY,EAAgB,CAAC,EAEhDE,EAAU,OAAO,KAAKD,EAAeV,CAAQ,EAC7CE,EAAOS,EAAQ,SAAS,EAAGlB,CAAU,EACrCQ,EAAKU,EAAQ,SAASlB,EAAYA,EAAaD,CAAQ,EACvDoB,EAAenB,EAAaD,EAC5Bc,EAAUK,EAAQ,SAASC,EAAcA,EAAetB,CAAS,EACjEe,EAAgBM,EAAQ,SAASC,EAAetB,CAAS,EACzDa,EAAMf,EAAO,WAAWU,EAAWI,EAAMR,CAAS,EAClDmB,EAAWzB,EAAO,iBAAiBC,EAAWc,EAAKF,CAAE,EAC3D,OAAAY,EAAS,WAAWP,CAAO,EAEpBO,EAAS,OAAOR,CAAa,EAAIQ,EAAS,MAAM,MAAM,CAEjE,OAASC,EAAP,CACE,MAAIA,GAAO,UAAY,mDACb,IAAI,MAAM,+DAA+D,EAEzE,IAAI,MAAM,8CAA8CA,GAAO,SAAS,CAEtF,CACJ","names":["crypto","algorithm","tagLength","defaultEncoding","ivLength","saltLength","keyLength","encodingSeparator","encrypt","data","secretKey","options","encoding","iv","salt","key","cipher","encryptedText","authTag","result","decrypt","encodingIndex","encryptedData","rawData","authTagIndex","decipher","error"]}